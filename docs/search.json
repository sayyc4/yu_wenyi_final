[
  {
    "objectID": "section2.html",
    "href": "section2.html",
    "title": "Affordable Housing Distribution vs Low-Income Population",
    "section": "",
    "text": "The relationship between affordable housing distribution and low-income population distribution is a critical starting point for this analysis. Affordable housing is intended to address the needs of low-income populations, so comparing these distributions helps to identify whether housing resources are effectively located to serve those who need them most. Any misalignment between the two could indicate gaps in accessibility or inequities in resource allocation.\n\n\nCode\nimport pandas as pd\nimport geopandas as gpd\nimport hvplot.pandas\nimport holoviews as hv\nfrom shapely.geometry import Point\nhv.extension('bokeh')\n\n# Load datasets\naffordable_housing_data = pd.read_csv(\"./geographicdatascience_python_finalproject/database/Affordable_Housing_Production_by_Building_20241224.csv\")\nincome_data = pd.read_csv(\"./geographicdatascience_python_finalproject/database/Community_Development_Block_Grant__CDBG__Eligibility_by_Census_Tract_-_CSV_20241221.csv\")\ngeo_data = gpd.read_file(\"./geographicdatascience_python_finalproject/database/nyc_tracts.json\")\n\n# Convert latitude and longitude to geometry for GeoDataFrame\naffordable_housing_data[\"geometry\"] = affordable_housing_data.apply(\n    lambda row: Point(row[\"Longitude\"], row[\"Latitude\"]), axis=1\n)\n\n# Convert affordable housing data to GeoDataFrame\naffordable_housing_gdf = gpd.GeoDataFrame(\n    affordable_housing_data,\n    geometry=\"geometry\",\n    crs=\"EPSG:4326\"\n)\n\n# Ensure CRS matches between GeoDataFrames\naffordable_housing_gdf = affordable_housing_gdf.to_crs(geo_data.crs)\n\n# Perform spatial join between affordable housing data and census tracts\naffordable_housing_with_tracts = gpd.sjoin(affordable_housing_gdf, geo_data, how=\"left\", predicate=\"intersects\")\n\n# Summarize affordable housing count by census tract\nhousing_summary_by_tract = (\n    affordable_housing_with_tracts.groupby(\"BoroCT2020\")[\"Building ID\"]\n    .count()\n    .reset_index()\n)\nhousing_summary_by_tract.rename(columns={\"Building ID\": \"AffordableHousingCount\"}, inplace=True)\n\n# Merge affordable housing summary into geo_data\ngeo_data = geo_data.merge(housing_summary_by_tract, on=\"BoroCT2020\", how=\"left\")\ngeo_data[\"AffordableHousingCount\"] = geo_data[\"AffordableHousingCount\"].fillna(0)\n\n# Match income data with geo_data using BoroCT fields\nincome_data[\"BoroCT\"] = income_data[\"BoroCT\"].astype(str).str.zfill(11)\ngeo_data[\"BoroCT2020\"] = geo_data[\"BoroCT2020\"].astype(str).str.zfill(11)\n\n# Merge low-income population data into geo_data\ngeo_data = geo_data.merge(\n    income_data[[\"BoroCT\", \"LowMod_Population\"]], left_on=\"BoroCT2020\", right_on=\"BoroCT\", how=\"left\"\n)\ngeo_data[\"LowMod_Population\"] = geo_data[\"LowMod_Population\"].fillna(0)\n\n# Map Affordable Housing Distribution\nmap_affordable_housing = geo_data.hvplot.polygons(\n    \"geometry\",\n    color=\"AffordableHousingCount\",  # Map AffordableHousingCount to color\n    cmap=\"Reds\",\n    line_color=\"white\",\n    hover_cols=[\"BoroCT2020\", \"AffordableHousingCount\"],  # Display BoroCT2020 and AffordableHousingCount on hover\n    title=\"Affordable Housing Distribution by Census Tract\",\n    aspect='equal',\n    clim=(0, 50),  # Set color range between 0 and 50\n    clipping_colors={'max': 'darkred'},  # Values above 50 will be dark red\n    colorbar=True\n)\n\n# Map Low-Income Population Overlay\nmap_low_income = geo_data.hvplot.polygons(\n    \"geometry\",\n    color=\"LowMod_Population\",  # Map LowMod_Population to color\n    cmap=\"Greens\",\n    line_color=\"white\",\n    hover_cols=[\"BoroCT2020\", \"LowMod_Population\"],  # Display BoroCT2020 and LowMod_Population on hover\n    title=\"Low-Income Population by Census Tract\",\n    aspect='equal',\n    colorbar=True  # Display color bar\n)\n\n# Combine Maps for Visualization\n(map_affordable_housing + map_low_income).cols(1)"
  },
  {
    "objectID": "section2.html#distribution-comparision",
    "href": "section2.html#distribution-comparision",
    "title": "Affordable Housing Distribution vs Low-Income Population",
    "section": "",
    "text": "The relationship between affordable housing distribution and low-income population distribution is a critical starting point for this analysis. Affordable housing is intended to address the needs of low-income populations, so comparing these distributions helps to identify whether housing resources are effectively located to serve those who need them most. Any misalignment between the two could indicate gaps in accessibility or inequities in resource allocation.\n\n\nCode\nimport pandas as pd\nimport geopandas as gpd\nimport hvplot.pandas\nimport holoviews as hv\nfrom shapely.geometry import Point\nhv.extension('bokeh')\n\n# Load datasets\naffordable_housing_data = pd.read_csv(\"./geographicdatascience_python_finalproject/database/Affordable_Housing_Production_by_Building_20241224.csv\")\nincome_data = pd.read_csv(\"./geographicdatascience_python_finalproject/database/Community_Development_Block_Grant__CDBG__Eligibility_by_Census_Tract_-_CSV_20241221.csv\")\ngeo_data = gpd.read_file(\"./geographicdatascience_python_finalproject/database/nyc_tracts.json\")\n\n# Convert latitude and longitude to geometry for GeoDataFrame\naffordable_housing_data[\"geometry\"] = affordable_housing_data.apply(\n    lambda row: Point(row[\"Longitude\"], row[\"Latitude\"]), axis=1\n)\n\n# Convert affordable housing data to GeoDataFrame\naffordable_housing_gdf = gpd.GeoDataFrame(\n    affordable_housing_data,\n    geometry=\"geometry\",\n    crs=\"EPSG:4326\"\n)\n\n# Ensure CRS matches between GeoDataFrames\naffordable_housing_gdf = affordable_housing_gdf.to_crs(geo_data.crs)\n\n# Perform spatial join between affordable housing data and census tracts\naffordable_housing_with_tracts = gpd.sjoin(affordable_housing_gdf, geo_data, how=\"left\", predicate=\"intersects\")\n\n# Summarize affordable housing count by census tract\nhousing_summary_by_tract = (\n    affordable_housing_with_tracts.groupby(\"BoroCT2020\")[\"Building ID\"]\n    .count()\n    .reset_index()\n)\nhousing_summary_by_tract.rename(columns={\"Building ID\": \"AffordableHousingCount\"}, inplace=True)\n\n# Merge affordable housing summary into geo_data\ngeo_data = geo_data.merge(housing_summary_by_tract, on=\"BoroCT2020\", how=\"left\")\ngeo_data[\"AffordableHousingCount\"] = geo_data[\"AffordableHousingCount\"].fillna(0)\n\n# Match income data with geo_data using BoroCT fields\nincome_data[\"BoroCT\"] = income_data[\"BoroCT\"].astype(str).str.zfill(11)\ngeo_data[\"BoroCT2020\"] = geo_data[\"BoroCT2020\"].astype(str).str.zfill(11)\n\n# Merge low-income population data into geo_data\ngeo_data = geo_data.merge(\n    income_data[[\"BoroCT\", \"LowMod_Population\"]], left_on=\"BoroCT2020\", right_on=\"BoroCT\", how=\"left\"\n)\ngeo_data[\"LowMod_Population\"] = geo_data[\"LowMod_Population\"].fillna(0)\n\n# Map Affordable Housing Distribution\nmap_affordable_housing = geo_data.hvplot.polygons(\n    \"geometry\",\n    color=\"AffordableHousingCount\",  # Map AffordableHousingCount to color\n    cmap=\"Reds\",\n    line_color=\"white\",\n    hover_cols=[\"BoroCT2020\", \"AffordableHousingCount\"],  # Display BoroCT2020 and AffordableHousingCount on hover\n    title=\"Affordable Housing Distribution by Census Tract\",\n    aspect='equal',\n    clim=(0, 50),  # Set color range between 0 and 50\n    clipping_colors={'max': 'darkred'},  # Values above 50 will be dark red\n    colorbar=True\n)\n\n# Map Low-Income Population Overlay\nmap_low_income = geo_data.hvplot.polygons(\n    \"geometry\",\n    color=\"LowMod_Population\",  # Map LowMod_Population to color\n    cmap=\"Greens\",\n    line_color=\"white\",\n    hover_cols=[\"BoroCT2020\", \"LowMod_Population\"],  # Display BoroCT2020 and LowMod_Population on hover\n    title=\"Low-Income Population by Census Tract\",\n    aspect='equal',\n    colorbar=True  # Display color bar\n)\n\n# Combine Maps for Visualization\n(map_affordable_housing + map_low_income).cols(1)"
  },
  {
    "objectID": "section2.html#k-means-cluster-analysis-for-income-and-affordable-housing",
    "href": "section2.html#k-means-cluster-analysis-for-income-and-affordable-housing",
    "title": "Affordable Housing Distribution vs Low-Income Population",
    "section": "2.2 K-Means Cluster Analysis for Income and Affordable Housing",
    "text": "2.2 K-Means Cluster Analysis for Income and Affordable Housing\nFirstly, we cleaned the data, excluded singular values to avoid disturbed results. Then, according to the elbow method, we chose k=3 as our optimal cluster number.\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom sklearn.cluster import KMeans\nfrom sklearn.preprocessing import StandardScaler\nimport hvplot.pandas\nplt.style.use('default')\n\n# Step 1: Prepare the Data\n# Select features for clustering\nclustering_data = geo_data[[\"AffordableHousingCount\", \"LowMod_Population\"]].copy()\n\n# Step 2: Identify and Remove Outliers\n# Calculate IQR for both features\nQ1 = clustering_data.quantile(0.25)\nQ3 = clustering_data.quantile(0.75)\nIQR = Q3 - Q1\n\n# Define outlier thresholds\nlower_bound = Q1 - 1.5 * IQR\nupper_bound = Q3 + 1.5 * IQR\n\n# Filter out outliers\nnon_outliers = ~((clustering_data &lt; lower_bound) | (clustering_data &gt; upper_bound)).any(axis=1)\n\n# Filter geo_data to only include non-outliers\ngeo_data_filtered = geo_data[non_outliers].copy()\nclustering_data_filtered = clustering_data[non_outliers].copy()\n\n# Step 3: Normalize the Filtered Data\nscaler = StandardScaler()\nclustering_data_scaled_filtered = scaler.fit_transform(clustering_data_filtered)\n\n# Step 4: Determine Optimal Number of Clusters\ninertia = []\nfor n_clusters in range(2, 10):\n    kmeans = KMeans(n_clusters=n_clusters, random_state=42)\n    kmeans.fit(clustering_data_scaled_filtered)\n    inertia.append(kmeans.inertia_)\n\n# Plot the Elbow Curve\nplt.figure(figsize=(8, 5))\nplt.plot(range(2, 10), inertia, marker='o')\nplt.title(\"Elbow Method for Optimal Clusters (Filtered Data)\")\nplt.xlabel(\"Number of Clusters\")\nplt.ylabel(\"Inertia\")\nplt.grid(True)\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\nCode\n# Step 5: Fit KMeans Model with Optimal Clusters\noptimal_clusters = 3  # Adjust this value based on the Elbow Curve\nkmeans_filtered = KMeans(n_clusters=optimal_clusters, random_state=42)\ngeo_data_filtered[\"Cluster\"] = kmeans_filtered.fit_predict(clustering_data_scaled_filtered)\ngeo_data_filtered[\"Cluster\"] = geo_data_filtered[\"Cluster\"].astype(str)  # Convert to string for better visualization\n\n# Step 6: Visualize Clustering Results\ncluster_map_filtered = geo_data_filtered.hvplot.polygons(\n    \"geometry\",\n    color=\"Cluster\",  # Use Cluster column for coloring\n    cmap={  # Map each cluster to a specific color\n        0: \"#fffbdf\",  \n        1: \"#ff6f64\",  \n        2: \"#ffb164\", \n    },\n    line_color=\"white\",\n    hover_cols=[\"AffordableHousingCount\", \"LowMod_Population\", \"Cluster\"],\n    title=\"Clustering Analysis of Affordable Housing and Low-Income Population (Filtered)\",\n    aspect='equal',\n    colorbar=False\n)\n\n# Display the filtered map\ncluster_map_filtered\n\n\n\n\n\n\n  \n\n\n\n\nThe Cluster results show a trend of dispersion and aggregation, indicating that affordable housing and low-income groups tend to gather in New York.\n\n\nCode\nimport matplotlib.pyplot as plt\nfrom sklearn.preprocessing import StandardScaler\n\n# Step 1: Ensure the Cluster column is of integer type\ngeo_data_filtered[\"Cluster\"] = geo_data_filtered[\"Cluster\"].astype(int)\n\n# Step 2: Define colors for clusters and create a mapping\ncluster_colors_filtered = {\n    0: \"#fffbdf\",\n    1: \"#ff6f64\",\n    2: \"#ffb164\"\n}\n\n# Step 3: Scaling setup (same as before)\nscaler = StandardScaler()\nscaler.fit(clustering_data_filtered)\ncenters_original = scaler.inverse_transform(kmeans_filtered.cluster_centers_)\n\n# Step 4: Plot with explicit color mapping\nplt.figure(figsize=(8, 5))\nfor cluster_id in range(optimal_clusters):\n    cluster_points = geo_data_filtered[geo_data_filtered[\"Cluster\"] == cluster_id]\n    plt.scatter(\n        cluster_points[\"AffordableHousingCount\"],\n        cluster_points[\"LowMod_Population\"],\n        label=f\"Cluster {cluster_id}\",\n        color=cluster_colors_filtered[cluster_id],  # Use dictionary mapping\n        alpha=0.8\n    )\n\n\n# Step 5: Plot cluster centers in the original feature space\nplt.scatter(\n    centers_original[:, 0],  # AffordableHousingCount\n    centers_original[:, 1],  # LowMod_Population\n    c=\"black\",\n    marker=\"X\",\n    s=250,  # Size of cluster center markers\n    label=\"Cluster Centers\"\n)\n\n# Step 6: Customize the plot\nplt.title(\"KMeans Clustering (Original Feature Space - Filtered)\", fontsize=18)\nplt.xlabel(\"Affordable Housing Count\", fontsize=14)\nplt.ylabel(\"Low-Income Population\", fontsize=14)\nplt.grid(color='gray', linestyle='--', linewidth=0.5)\n\n# Step 7: Adjust legend position\nplt.legend(title=\"Clusters\", fontsize=12, loc='upper right', bbox_to_anchor=(1.15, 1))\n\n# Step 8: Display the plot\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\n\nIt can be seen that low-income groups and affordable housing are mainly divided into three categories, mainly based on the comprehensive affect of low income and the number of affordable housing. Next, we calculated the corresponding linear relationship between low income and affordable housing theselves. The following conclusions were obtained.\n\n\nCode\n# Use the filtered data for correlation analysis\ncorrelation_filtered, p_value_filtered = pearsonr(\n    geo_data_filtered[\"AffordableHousingCount\"], geo_data_filtered[\"LowMod_Population\"]\n)\nprint(f\"Filtered Correlation: {correlation_filtered}, P-value: {p_value_filtered}\")\n\n\n\nResults and Interpretation\n\nFiltered Correlation: 0.30 (weak positive correlation)\nP-value: 2.57e-43 (statistically significant)\n\n\n\nConclusion\nSurprisingly, according to the data, there is a weak but statistically significant positive relationship between low-income population and affordable housing. This suggests some alignment between housing needs and supply, but the weak correlation indicates other factors might dilute the relationship, such as zoning laws, policy gaps, or spatial mismatches. Therefore, our next step is to explore more factors."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site"
  },
  {
    "objectID": "section3.html",
    "href": "section3.html",
    "title": "Affordable Housing Distribution vs Privately Owned Public Spaces (POPS)",
    "section": "",
    "text": "Following this, the analysis focuses on the distribution of Privately Owned Public Spaces (POPS). These spaces contribute to urban livability and accessibility, particularly for communities with limited access to public amenities. Examining the distribution of POPS in relation to affordable housing and low-income populations allows for a better understanding of whether these shared resources are equitably distributed or concentrated in specific areas.\n\n\nCode\nimport pandas as pd\nimport geopandas as gpd\nimport hvplot.pandas\nimport holoviews as hv\nfrom shapely.geometry import Point\n\nhv.extension('bokeh')\n\n# Load datasets\naffordable_housing_data = pd.read_csv(\"./geographicdatascience_python_finalproject/database/Affordable_Housing_Production_by_Building_20241224.csv\")\npops_data = pd.read_csv(\"./geographicdatascience_python_finalproject/database/Privately Owned Public Spaces_pops_24v2_csv/pops_24v2.csv\")\ngeo_data = gpd.read_file(\"./geographicdatascience_python_finalproject/database/nyc_tracts.json\")\n\n# Step 1: Prepare Affordable Housing Data\n# Convert latitude and longitude to geometry for GeoDataFrame\naffordable_housing_data[\"geometry\"] = affordable_housing_data.apply(\n    lambda row: Point(row[\"Longitude\"], row[\"Latitude\"]), axis=1\n)\n\n# Convert to GeoDataFrame\naffordable_housing_gdf = gpd.GeoDataFrame(\n    affordable_housing_data,\n    geometry=\"geometry\",\n    crs=\"EPSG:4326\"\n)\n\n# Ensure CRS matches between GeoDataFrames\naffordable_housing_gdf = affordable_housing_gdf.to_crs(geo_data.crs)\n\n# Summarize affordable housing count by census tract\naffordable_housing_with_tracts = gpd.sjoin(affordable_housing_gdf, geo_data, how=\"left\", predicate=\"intersects\")\nhousing_summary_by_tract = (\n    affordable_housing_with_tracts.groupby(\"BoroCT2020\")[\"Building ID\"]\n    .count()\n    .reset_index()\n)\nhousing_summary_by_tract.rename(columns={\"Building ID\": \"AffordableHousingCount\"}, inplace=True)\n\n# Merge affordable housing summary into geo_data\ngeo_data = geo_data.merge(housing_summary_by_tract, on=\"BoroCT2020\", how=\"left\")\ngeo_data[\"AffordableHousingCount\"] = geo_data[\"AffordableHousingCount\"].fillna(0)\n\n# Step 2: Prepare POPS Data\n# Ensure numeric data types in pops_data for longitude and latitude\npops_data[\"longitude\"] = pd.to_numeric(pops_data[\"longitude\"], errors=\"coerce\")\npops_data[\"latitude\"] = pd.to_numeric(pops_data[\"latitude\"], errors=\"coerce\")\n\n# Drop rows with missing or invalid coordinates\npops_data = pops_data.dropna(subset=[\"longitude\", \"latitude\"])\n\n# Convert POPS data to GeoDataFrame\npops_data[\"geometry\"] = pops_data.apply(\n    lambda row: Point(row[\"longitude\"], row[\"latitude\"]), axis=1\n)\npops_gdf = gpd.GeoDataFrame(\n    pops_data,\n    geometry=\"geometry\",\n    crs=\"EPSG:4326\"\n)\n\n# Ensure CRS matches\npops_gdf = pops_gdf.to_crs(geo_data.crs)\n\npops_with_tracts = gpd.sjoin(pops_gdf, geo_data, how=\"left\", predicate=\"within\")\npops_summary = pops_with_tracts.groupby(\"BoroCT2020\").size().reset_index(name=\"POPS_Count\")\n\ngeo_data = geo_data.merge(pops_summary, on=\"BoroCT2020\", how=\"left\")\ngeo_data[\"POPS_Count\"] = geo_data[\"POPS_Count\"].fillna(0)  # Fill missing counts with 0\n\n\n# Affordable Housing Map\nmap_affordable_housing = geo_data.hvplot.polygons(\n    \"geometry\",\n    color=\"AffordableHousingCount\",\n    cmap=\"Reds\",\n    line_color=\"white\",\n    hover_cols=[\"BoroCT2020\", \"AffordableHousingCount\"],\n    title=\"Affordable Housing Distribution by Census Tract\",\n    aspect=\"equal\",\n    clim=(0, 50),\n    clipping_colors={\"max\": \"darkred\"},\n    colorbar=True\n)\n\n# POPS Map\nmap_pops = geo_data.hvplot.polygons(\n    \"geometry\",\n    color=\"POPS_Count\",\n    cmap=\"Blues\",\n    line_color=\"white\",\n    hover_cols=[\"BoroCT2020\", \"POPS_Count\"],\n    title=\"POPS Distribution by Census Tract\",\n    aspect=\"equal\",\n    colorbar=True\n)\n\n# Combined Map\ncombined_map = map_affordable_housing + map_pops\ncombined_map\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\nIf we zoom in on the distribution of POPS, we can see that it is basically dispersed in places where there are very few affordable housing, suggesting that there may be a negative correlation between the two. Next, we will test this through linear correlation analysis and cluster analysis."
  },
  {
    "objectID": "section4.html",
    "href": "section4.html",
    "title": "K-Means Analysis of Three Factors",
    "section": "",
    "text": "Code\n# Load datasets\nimport pandas as pd\nimport geopandas as gpd\nimport hvplot.pandas\nimport holoviews as hv\nfrom shapely.geometry import Point\naffordable_housing_data = pd.read_csv(\"./geographicdatascience_python_finalproject/database/Affordable_Housing_Production_by_Building_20241224.csv\")\npops_data = pd.read_csv(\"./geographicdatascience_python_finalproject/database/Privately Owned Public Spaces_pops_24v2_csv/pops_24v2.csv\")\ngeo_data = gpd.read_file(\"./geographicdatascience_python_finalproject/database/nyc_tracts.json\")\n\n# Step 1: Prepare Affordable Housing Data\n# Convert latitude and longitude to geometry for GeoDataFrame\naffordable_housing_data[\"geometry\"] = affordable_housing_data.apply(\n    lambda row: Point(row[\"Longitude\"], row[\"Latitude\"]), axis=1\n)\n\n# Convert to GeoDataFrame\naffordable_housing_gdf = gpd.GeoDataFrame(\n    affordable_housing_data,\n    geometry=\"geometry\",\n    crs=\"EPSG:4326\"\n)\n\n# Ensure CRS matches between GeoDataFrames\naffordable_housing_gdf = affordable_housing_gdf.to_crs(geo_data.crs)\n\n# Summarize affordable housing count by census tract\naffordable_housing_with_tracts = gpd.sjoin(affordable_housing_gdf, geo_data, how=\"left\", predicate=\"intersects\")\nhousing_summary_by_tract = (\n    affordable_housing_with_tracts.groupby(\"BoroCT2020\")[\"Building ID\"]\n    .count()\n    .reset_index()\n)\nhousing_summary_by_tract.rename(columns={\"Building ID\": \"AffordableHousingCount\"}, inplace=True)\n\n# Merge affordable housing summary into geo_data\ngeo_data = geo_data.merge(housing_summary_by_tract, on=\"BoroCT2020\", how=\"left\")\ngeo_data[\"AffordableHousingCount\"] = geo_data[\"AffordableHousingCount\"].fillna(0)\n\n# Step 2: Prepare POPS Data\n# Ensure numeric data types in pops_data for longitude and latitude\npops_data[\"longitude\"] = pd.to_numeric(pops_data[\"longitude\"], errors=\"coerce\")\npops_data[\"latitude\"] = pd.to_numeric(pops_data[\"latitude\"], errors=\"coerce\")\n\n# Drop rows with missing or invalid coordinates\npops_data = pops_data.dropna(subset=[\"longitude\", \"latitude\"])\n\n# Convert POPS data to GeoDataFrame\npops_data[\"geometry\"] = pops_data.apply(\n    lambda row: Point(row[\"longitude\"], row[\"latitude\"]), axis=1\n)\npops_gdf = gpd.GeoDataFrame(\n    pops_data,\n    geometry=\"geometry\",\n    crs=\"EPSG:4326\"\n)\n\n# Ensure CRS matches\npops_gdf = pops_gdf.to_crs(geo_data.crs)\n\npops_with_tracts = gpd.sjoin(pops_gdf, geo_data, how=\"left\", predicate=\"within\")\npops_summary = pops_with_tracts.groupby(\"BoroCT2020\").size().reset_index(name=\"POPS_Count\")\n\ngeo_data = geo_data.merge(pops_summary, on=\"BoroCT2020\", how=\"left\")\ngeo_data[\"POPS_Count\"] = geo_data[\"POPS_Count\"].fillna(0)  # Fill missing counts with 0\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom sklearn.cluster import KMeans\nfrom sklearn.preprocessing import StandardScaler\nimport hvplot.pandas\nimport pandas as pd\nplt.style.use(\"default\")\n\n# Step 1: Recalculate LowMod_Population\n# Load income data and ensure correct format\nincome_data = pd.read_csv(\"./geographicdatascience_python_finalproject/database/Community_Development_Block_Grant__CDBG__Eligibility_by_Census_Tract_-_CSV_20241221.csv\")\nincome_data[\"BoroCT\"] = income_data[\"BoroCT\"].astype(str).str.zfill(11)\ngeo_data[\"BoroCT2020\"] = geo_data[\"BoroCT2020\"].astype(str).str.zfill(11)\n\n# Merge LowMod_Population into geo_data\ngeo_data = geo_data.merge(\n    income_data[[\"BoroCT\", \"LowMod_Population\"]], left_on=\"BoroCT2020\", right_on=\"BoroCT\", how=\"left\"\n)\ngeo_data[\"LowMod_Population\"] = geo_data[\"LowMod_Population\"].fillna(0)\n\n# Step 2: Prepare Data for KMeans\nclustering_data = geo_data[[\"AffordableHousingCount\", \"LowMod_Population\", \"POPS_Count\"]].copy()\n\n# Step 3: Remove Outliers\n# Calculate IQR for features\nQ1 = clustering_data.quantile(0.25)\nQ3 = clustering_data.quantile(0.75)\nIQR = Q3 - Q1\nlower_bound = Q1 - 1.5 * IQR\nupper_bound = Q3 + 1.5 * IQR\n\n# Filter non-outliers\nnon_outliers = ~((clustering_data &lt; lower_bound) | (clustering_data &gt; upper_bound)).any(axis=1)\ngeo_data_filtered = geo_data[non_outliers].copy()\nclustering_data_filtered = clustering_data[non_outliers].copy()\n\n# Step 4: Normalize the Filtered Data\nscaler = StandardScaler()\nclustering_data_scaled_filtered = scaler.fit_transform(clustering_data_filtered)\n\n# Step 5: Determine Optimal Number of Clusters\ninertia = []\nfor n_clusters in range(2, 10):\n    kmeans = KMeans(n_clusters=n_clusters, random_state=42)\n    kmeans.fit(clustering_data_scaled_filtered)\n    inertia.append(kmeans.inertia_)\n\nplt.figure(figsize=(8, 5))\nplt.plot(range(2, 10), inertia, marker=\"o\")\nplt.title(\"Elbow Method for Optimal Clusters (Filtered Data)\")\nplt.xlabel(\"Number of Clusters\")\nplt.ylabel(\"Inertia\")\nplt.grid(True)\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\nCode\n# Step 6: Fit KMeans with Optimal Number of Clusters\noptimal_clusters = 3  # Adjust based on the elbow curve\nkmeans = KMeans(n_clusters=optimal_clusters, random_state=42)\ngeo_data_filtered[\"Cluster\"] = kmeans.fit_predict(clustering_data_scaled_filtered)\n\n# Step 7: Visualize the Map\nmap_clusters = geo_data_filtered.hvplot.polygons(\n    \"geometry\",\n    color=\"Cluster\",\n    cmap={  # Map each cluster to a specific color\n        0: \"#ff6f64\",  \n        1: \"#fffbdf\",  \n        2: \"#ffb164\", \n    },    \n    line_color=\"white\",\n    hover_cols=[\"AffordableHousingCount\", \"LowMod_Population\", \"POPS_Count\", \"Cluster\"],\n    title=\"Clustering Analysis of Affordable Housing, Low-Income Population, and POPS\",\n    aspect=\"equal\",\n    colorbar=True\n)\n\nmap_clusters\n\n\n\n\n\n\n  \n\n\n\n\n\n\nCode\nimport matplotlib.pyplot as plt\nfrom sklearn.preprocessing import StandardScaler\n\n# Step 1: Prepare the Feature Space\n# Use the filtered data and ensure Cluster is integer type\ngeo_data_filtered[\"Cluster\"] = geo_data_filtered[\"Cluster\"].astype(int)\n\n# Step 2: Retrieve Original Cluster Centers\n# Reverse scaling to obtain cluster centers in the original feature space\ncenters_scaled = kmeans.cluster_centers_\nscaler = StandardScaler()\nscaler.fit(clustering_data_filtered)  # Refit scaler to filtered data\ncenters_original = scaler.inverse_transform(centers_scaled)\n\n# Step 3: Define Colors for Clusters\ncluster_colors = [\"#ff6f64\", \"#fffbdf\", \"#ffb164\"] \n\n# Step 4: Plot the Feature Space\nplt.figure(figsize=(8, 5))\nfor cluster_id in range(optimal_clusters):\n    # Filter data points belonging to the current cluster\n    cluster_points = geo_data_filtered[geo_data_filtered[\"Cluster\"] == cluster_id]\n    plt.scatter(\n        cluster_points[\"AffordableHousingCount\"],\n        cluster_points[\"LowMod_Population\"],\n        label=f\"Cluster {cluster_id}\",\n        color=cluster_colors[cluster_id],\n        alpha=0.8\n    )\n\n# Step 5: Plot Cluster Centers\nplt.scatter(\n    centers_original[:, 0],\n    centers_original[:, 1],\n    c=\"black\",\n    marker=\"X\",\n    s=250,  # Increase size for better visibility\n    label=\"Cluster Centers\"\n)\n\n# Step 6: Customize the Plot\nplt.title(\"KMeans Clustering (Original Feature Space)\", fontsize=18)\nplt.xlabel(\"Affordable Housing Count\", fontsize=14)\nplt.ylabel(\"Low-Income Population\", fontsize=14)\nplt.grid(color='gray', linestyle='--', linewidth=0.5)\n\n# Step 7: Add Legend\nplt.legend(title=\"Clusters\", fontsize=12, loc='upper right', bbox_to_anchor=(1.15, 1))\n\n# Step 8: Adjust Layout and Display\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\nCode\nfrom scipy.stats import pearsonr\n\n# Calculate correlation between POPS_Count and AffordableHousingCount\ncorrelation_pops_affordable, p_value_pops_affordable = pearsonr(\n    geo_data[\"POPS_Count\"], geo_data[\"AffordableHousingCount\"]\n)\nprint(f\"Correlation between POPS_Count and AffordableHousingCount: {correlation_pops_affordable}, P-value: {p_value_pops_affordable}\")\n\n# Calculate correlation between POPS_Count and LowMod_Population\ncorrelation_pops_lowmod, p_value_pops_lowmod = pearsonr(\n    geo_data[\"POPS_Count\"], geo_data[\"LowMod_Population\"]\n)\nprint(f\"Correlation between POPS_Count and LowMod_Population: {correlation_pops_lowmod}, P-value: {p_value_pops_lowmod}\")\n\n\n\n\n\nInteractive Diagram of Three Factors\n\n\nCode\nimport pandas as pd\nimport geopandas as gpd\nimport altair as alt\nfrom shapely.geometry import Point\nimport numpy as np\n\n# Load datasets\naffordable_housing_data = pd.read_csv(\"./geographicdatascience_python_finalproject/database/Affordable_Housing_Production_by_Building_20241224.csv\")\npops_data = pd.read_csv(\"./geographicdatascience_python_finalproject/database/Privately Owned Public Spaces_pops_24v2_csv/pops_24v2.csv\")\nincome_data = pd.read_csv(\"./geographicdatascience_python_finalproject/database/Community_Development_Block_Grant__CDBG__Eligibility_by_Census_Tract_-_CSV_20241221.csv\")\ngeo_data = gpd.read_file(\"./geographicdatascience_python_finalproject/database/nyc_tracts.json\")\n\n# Step 1: Prepare Income Data\nincome_data[\"BoroCT\"] = income_data[\"BoroCT\"].astype(str).str.zfill(11)\ngeo_data[\"BoroCT2020\"] = geo_data[\"BoroCT2020\"].astype(str).str.zfill(11)\n\n# Merge Low-Income Population Data into geo_data\ngeo_data = geo_data.merge(\n    income_data[[\"BoroCT\", \"LowMod_Population\"]],\n    left_on=\"BoroCT2020\",\n    right_on=\"BoroCT\",\n    how=\"left\"\n)\ngeo_data[\"LowMod_Population\"] = geo_data[\"LowMod_Population\"].fillna(0)\n\n# Step 2: Prepare Affordable Housing Data\naffordable_housing_data[\"geometry\"] = affordable_housing_data.apply(\n    lambda row: Point(row[\"Longitude\"], row[\"Latitude\"]), axis=1\n)\naffordable_housing_gdf = gpd.GeoDataFrame(\n    affordable_housing_data, geometry=\"geometry\", crs=\"EPSG:4326\"\n)\naffordable_housing_gdf = affordable_housing_gdf.to_crs(geo_data.crs)\n\naffordable_housing_with_tracts = gpd.sjoin(affordable_housing_gdf, geo_data, how=\"left\", predicate=\"intersects\")\nhousing_summary_by_tract = (\n    affordable_housing_with_tracts.groupby(\"BoroCT2020\")[\"Building ID\"]\n    .count()\n    .reset_index()\n)\nhousing_summary_by_tract.rename(columns={\"Building ID\": \"AffordableHousingCount\"}, inplace=True)\ngeo_data = geo_data.merge(housing_summary_by_tract, on=\"BoroCT2020\", how=\"left\")\ngeo_data[\"AffordableHousingCount\"] = geo_data[\"AffordableHousingCount\"].fillna(0)\n\n# Step 3: Prepare POPS Data\npops_data[\"longitude\"] = pd.to_numeric(pops_data[\"longitude\"], errors=\"coerce\")\npops_data[\"latitude\"] = pd.to_numeric(pops_data[\"latitude\"], errors=\"coerce\")\npops_data = pops_data.dropna(subset=[\"longitude\", \"latitude\"])\npops_data[\"geometry\"] = pops_data.apply(lambda row: Point(row[\"longitude\"], row[\"latitude\"]), axis=1)\npops_gdf = gpd.GeoDataFrame(pops_data, geometry=\"geometry\", crs=\"EPSG:4326\")\npops_gdf = pops_gdf.to_crs(geo_data.crs)\n\npops_with_tracts = gpd.sjoin(pops_gdf, geo_data, how=\"left\", predicate=\"within\")\npops_summary = pops_with_tracts.groupby(\"BoroCT2020\").size().reset_index(name=\"POPS_Count\")\ngeo_data = geo_data.merge(pops_summary, on=\"BoroCT2020\", how=\"left\")\ngeo_data[\"POPS_Count\"] = geo_data[\"POPS_Count\"].fillna(0)\n\n# Step 4: Remove Only Maximum Outliers\ncolumns_to_check = [\"AffordableHousingCount\", \"LowMod_Population\", \"POPS_Count\"]\n\n# Remove rows with the maximum value in each column\nfor col in columns_to_check:\n    max_value = geo_data[col].max()\n    geo_data = geo_data[geo_data[col] != max_value]\n\n# Step 5: Prepare Data for Altair\ngeo_data[\"BoroCT2020\"] = geo_data[\"BoroCT2020\"].astype(str)\ndata_for_altair = geo_data[[\"BoroCT2020\", \"AffordableHousingCount\", \"POPS_Count\", \"LowMod_Population\"]].copy()\ndata_for_altair[\"POPS_Count_Log\"] = np.log1p(data_for_altair[\"POPS_Count\"])\n\n# Step 6: Define Altair Selection\nbrush = alt.selection(type='interval')\n\n# Scatter Plot: Affordable Housing vs Low-Income Population\nscatter_affordable_vs_income = alt.Chart(data_for_altair).mark_circle(size=60).encode(\n    x=alt.X(\"AffordableHousingCount:Q\", title=\"Affordable Housing Count\"),\n    y=alt.Y(\"LowMod_Population:Q\", title=\"Low-Income Population\"),\n    color=alt.condition(brush, \"POPS_Count_Log:Q\", alt.value(\"lightgray\"), scale=alt.Scale(scheme=\"blues\")),\n    tooltip=[\"BoroCT2020\", \"AffordableHousingCount\", \"LowMod_Population\", \"POPS_Count\"]\n).add_selection(\n    brush\n).properties(\n    title=\"Affordable Housing vs Low-Income Population\",\n    width=400,\n    height=300\n)\n\n# Bar Chart: POPS Count\nbar_pops = alt.Chart(data_for_altair).mark_bar().encode(\n    x=alt.X(\"POPS_Count:Q\", title=\"POPS Count\"),\n    y=alt.Y(\"count():Q\", title=\"Number of Census Tracts\"),\n    color=alt.Color(\"POPS_Count_Log:Q\", scale=alt.Scale(scheme=\"blues\")),\n    tooltip=[\"POPS_Count\", \"count()\"]\n).transform_filter(\n    brush\n).properties(\n    title=\"Distribution of POPS Count\",\n    width=400,\n    height=300\n)\n\n# Combine Plots\nlinked_charts = scatter_affordable_vs_income & bar_pops\nlinked_charts\n\n\n\n\n\n\n\n\n\n\nResults and Interpretation\n\nCorrelation Between Affordable Housing and Low-Income Population:\n\nFiltered Correlation: 0.30 (weak positive correlation)\n\nP-value: 2.57e-43 (statistically significant)\n\nCorrelation Between POPS_Count and Affordable Housing Count:\n\nCorrelation: -0.039 (negligible negative correlation)\n\nP-value: 0.058 (not statistically significant)\n\nCorrelation Between POPS_Count and Low-Income Population:\n\nCorrelation: -0.082 (weak negative correlation)\n\nP-value: 7.48e-05 (statistically significant)\n\n\n\n\n\nConclusion and Analysis\n\nSummary of Affordable Housing and Low-Income Population:\nThe weak positive correlation between affordable housing and low-income population indicates some alignment between housing supply and demand, but the relationship is diluted by factors such as zoning, policy gaps, or spatial mismatches. This has been discussed previously in detail.\n\n\nPOPS Analysis:\nThe negligible or weak negative correlations involving POPS (Privately Owned Public Spaces) reveal that POPS has a minimal impact on either affordable housing distribution or low-income population density. This finding could be attributed to several factors:\n\nPurpose and Design of POPS:\nPOPS are typically designed to enhance public space accessibility in urban areas and are often mandated by zoning incentives rather than a direct response to socioeconomic needs. As a result, their placement is not strongly tied to affordable housing or low-income demographics.\nUrban Concentration:\nPOPS are often concentrated in high-density commercial or mixed-use areas, which may not overlap with residential neighborhoods or areas with significant affordable housing developments.\nSmall Scale:\nThe overall number of POPS sites is relatively small, and their area is limited, reducing their potential to significantly influence broader demographic patterns.\nZoning Policies:\nPOPS are frequently located in higher-income or business districts where developers are incentivized to provide public spaces. These areas are less likely to coincide with neighborhoods with high concentrations of affordable housing or low-income residents.\nInconsistent Accessibility:\nThe accessibility of POPS may not be uniformly beneficial to low-income populations. For example, certain POPS may be located in areas with poor transit connectivity or designed in ways that limit their usability.\n\n\n\nConclusion:\nWhile POPS are valuable as public spaces, their weak correlation with affordable housing and low-income population highlights their limited role in addressing housing affordability or socioeconomic disparities. This suggests that POPS serve more as urban design tools than as direct solutions to housing equity issues."
  }
]